{"root":{"data":{"id":"bxc998s9lnc0","created":1569736804657,"text":"Redis"},"children":[{"data":{"id":"bxc9a93roqo0","created":1569736883716,"text":"数据类型","layout":null},"children":[{"data":{"id":"bxc9arjf7e00","created":1569736923845,"text":"字符串 string","layout":null},"children":[{"data":{"id":"bydt8hy0phs0","created":1573550886826,"text":"应用","layout":null},"children":[{"data":{"id":"bydt8om876g0","created":1573550901351,"text":"缓存功能","layout":null},"children":[]},{"data":{"id":"bydt8pmcdpc0","created":1573550903535,"text":"计数器","layout":null},"children":[]},{"data":{"id":"bydt8qb16680","created":1573550905027,"text":"共享用户Session","layout":null},"children":[]}]}]},{"data":{"id":"bxc9au4lbzs0","created":1569736929479,"text":"散列表 hash","layout":null},"children":[{"data":{"id":"bydt8hy0phs0","created":1573550886826,"text":"应用","layout":null},"children":[{"data":{"id":"bydt8om876g0","created":1573550901351,"text":"一般就是可以将结构化的数据，\n比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，\n然后每次读写缓存的时候，可以就操作 Hash 里的某个字段","layout":null},"children":[]}]},{"data":{"id":"bydti8mzxi80","created":1573551650210,"text":"原理","layout":null},"children":[{"data":{"id":"bydtidefuig0","created":1573551660577,"text":"使用 数组 + 链表 的二维结构实现","layout":null},"children":[]}]}]},{"data":{"id":"bxc9aw0rg940","created":1569736933600,"text":"列表 list","layout":null},"children":[{"data":{"id":"bydt8hy0phs0","created":1573550886826,"text":"应用","layout":null},"children":[{"data":{"id":"bydt8om876g0","created":1573550901351,"text":"消息队列","layout":null},"children":[]},{"data":{"id":"bydt8pmcdpc0","created":1573550903535,"text":"文章列表或者数据分页展示的应用","layout":null},"children":[]}]},{"data":{"id":"bydti8mzxi80","created":1573551650210,"text":"原理","layout":null},"children":[{"data":{"id":"bydtidefuig0","created":1573551660577,"text":"使用 链表 实现","layout":null},"children":[]},{"data":{"id":"bydtj5gxgio0","created":1573551721677,"text":"插入删除操作很快，但 索引定位非常慢","layout":null},"children":[]}]}]},{"data":{"id":"bxc9ay7k5kw0","created":1569736938365,"text":"集合 set","layout":null},"children":[{"data":{"id":"bydtaydx4gg0","created":1573551079345,"text":"定义","layout":null},"children":[{"data":{"id":"bydtb4r7t8g0","created":1573551093209,"text":"无序集合，自动去重","layout":null},"children":[]}]},{"data":{"id":"bydt8hy0phs0","created":1573550886826,"text":"应用","layout":null},"children":[]}]},{"data":{"id":"bxc9uoogwkg0","created":1569738484903,"text":"有序集合 sorted set","layout":null},"children":[{"data":{"id":"bydt8hy0phs0","created":1573550886826,"text":"应用","layout":null},"children":[{"data":{"id":"bydt8om876g0","created":1573550901351,"text":"排行榜","layout":null},"children":[]},{"data":{"id":"bydt8pmcdpc0","created":1573550903535,"text":"带权重的队列","layout":null},"children":[]}]},{"data":{"id":"bydtjif4k5s0","created":1573551749866,"text":"原理","layout":null},"children":[{"data":{"id":"bydtjkr0f4w0","created":1573551754939,"text":"使用 跳表 实现","layout":null},"children":[]}]}]},{"data":{"id":"bxc9v98f6340","created":1569738529645,"text":"高级类型","layout":null},"children":[{"data":{"id":"bxca2qved9s0","created":1569739116589,"text":"bitmap","layout":null},"children":[]},{"data":{"id":"bxca2us2i880","created":1569739125095,"text":"hyperLogLog","layout":null},"children":[{"data":{"id":"byfix38b5yo0","created":1573724901605,"text":"供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV"},"children":[]}]},{"data":{"id":"bydqu43xytk0","created":1573544117391,"text":"BloomFilter","layout":null},"children":[{"data":{"id":"c1jqo6zpr540","created":1585121488541,"text":"本质上是bitmap位数组的扩展"},"children":[]},{"data":{"id":"c1jqqizitcw0","created":1585121671379,"text":"两大组件"},"children":[{"data":{"id":"c1jqqnetsug0","created":1585121681012,"text":"一定大小的BitAarry位阵列(具体大小和存储规模有关)"},"children":[]},{"data":{"id":"c1jqqreml0o0","created":1585121689707,"text":"N个优秀的哈希函数"},"children":[]}]}]},{"data":{"id":"bydqu8y5eig0","created":1573544127925,"text":"GeoHash","layout":null},"children":[]},{"data":{"id":"bydsyyw5nd40","created":1573550140077,"text":"Pub/Sub","layout":null},"children":[]},{"data":{"id":"bydsz3454xc0","created":1573550149267,"text":"Redis Module","layout":null},"children":[]},{"data":{"id":"bydsz6uuzrc0","created":1573550157413,"text":"RedisSearch","layout":null},"children":[]},{"data":{"id":"bydszhjy6m80","created":1573550180698,"text":"Redis-ML","layout":null},"children":[]}]},{"data":{"id":"bydtk52z9z40","created":1573551799198,"text":"其他","layout":null},"children":[{"data":{"id":"bydtk7hmxds0","created":1573551804438,"text":"Pipline","layout":null},"children":[]},{"data":{"id":"bydtkcy7hls0","created":1573551816324,"text":"事务","layout":null},"children":[]}]}]},{"data":{"id":"bxc9ahlw5wo0","created":1569736902226,"text":"内部数据结构","layout":null},"children":[{"data":{"id":"bxca4chq5gw0","created":1569739242016,"text":"dict","layout":null},"children":[]},{"data":{"id":"bxca4facqv40","created":1569739248100,"text":"sds","layout":null},"children":[]},{"data":{"id":"bxca4h75hs80","created":1569739252260,"text":"robj","layout":null},"children":[]},{"data":{"id":"bxca4k8lz5s0","created":1569739258879,"text":"ziplist","layout":null},"children":[]},{"data":{"id":"bxca4nmrye80","created":1569739266265,"text":"quicklist","layout":null},"children":[]},{"data":{"id":"bxc9b6ztxnc0","created":1569736957489,"text":"跳跃链表 skip list","layout":null},"children":[]},{"data":{"id":"bxca51zxuuo0","created":1569739297536,"text":"intset","layout":null},"children":[]}]},{"data":{"id":"bxc9vjwklo80","created":1569738552873,"text":"持久化策略","layout":null},"children":[{"data":{"id":"bxc9wg9q9xs0","created":1569738623326,"text":"快照方式持久化RDB","note":"快照方式持久化就是在某时刻把所有数据进行完整备份","layout":null},"children":[{"data":{"id":"bxc9y7trzso0","created":1569738761675,"text":"方式","layout":null},"children":[{"data":{"id":"bydspme90280","created":1573549407596,"text":"对 Redis 中的数据执行周期性的持久化\nRDB做镜像全量持久化","layout":null},"children":[]}]},{"data":{"id":"bxc9ybq5da00","created":1569738770163,"text":"原理","layout":null},"children":[{"data":{"id":"bydt5e4akds0","created":1573550643406,"text":"fork和cow。\nfork是指redis通过创建子进程来进行RDB操作，\ncow指的是copy on write，\n子进程创建后，父子进程共享数据段，父进程继续提供读写服务，\n写脏的页面数据会逐渐和子进程分离开来","layout":null},"children":[]}]},{"data":{"id":"bxc9yehdvkw0","created":1569738776163,"text":"优缺点","layout":null},"children":[{"data":{"id":"bxc9znmtgzc0","created":1569738874447,"text":"1. 生成多个数据文件\n2. 对Redis的性能影响非常小，是因为在同步数据的时候只是fork了一个子进程去做持久化的\n3. 数据恢复的时候速度比AOF快","layout":null},"children":[]},{"data":{"id":"bxc9zu3c7bs0","created":1569738888507,"text":"1. 数据完整性差，容易丢失数据\n2. RDB在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒\n消耗性能","layout":null},"children":[]}]},{"data":{"id":"bydsqilkpu00","created":1573549477696,"text":"RDB更适合做冷备","layout":null},"children":[]},{"data":{"id":"c1gblqsme5k0","created":1584774300037,"text":"SAVE 命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器"},"children":[{"data":{"id":"c1jqz6ehhco0","created":1585122349263,"text":"SAVE是阻塞式持久化"},"children":[]}]},{"data":{"id":"c1gblyv13540","created":1584774317597,"text":"BGSAVE 命令由子进程执行保存操作，所以该命令不会阻塞服务器"},"children":[{"data":{"id":"c1jqzblmycg0","created":1585122360580,"text":"BGSAVE属于非阻塞式持久化"},"children":[]}]}]},{"data":{"id":"bxc9wkfoxnk0","created":1569738632393,"text":"写日志方式持久化AOF","note":"写日志方式持久化就是把用户执行的所有写指令（增删改）备份到文件中，还原数据时只需要把备份的所有指令重新执行一遍即可","layout":null},"children":[{"data":{"id":"bxc9y7trzso0","created":1569738761675,"text":"方式","layout":null},"children":[{"data":{"id":"bydspsrylmo0","created":1573549421485,"text":"对每条写入命令作为日志，\n以 append-only 的模式写入一个日志文件中，\n因为这个模式是只追加的方式，\n所以没有任何磁盘寻址的开销，所以很快，\n有点像Mysql中的binlog\nAOF做增量持久化","layout":null},"children":[]}]},{"data":{"id":"bxc9ybq5da00","created":1569738770163,"text":"原理","layout":null},"children":[]},{"data":{"id":"bxc9yehdvkw0","created":1569738776163,"text":"优缺点","layout":null},"children":[{"data":{"id":"bxca1j2bi080","created":1569739021229,"text":"1. 数据完整性好\n2. 以append-only的方式去写的，只是追加的方式写数据，少了很多磁盘寻址的开销，写入性能好，文件也不容易破损\n3. AOF的日志是通过一个叫非常可读的方式记录的，易恢复","layout":null,"note":"AOF是一秒一次去通过一个后台的线程fsync操作，那最多丢这一秒的数据"},"children":[]},{"data":{"id":"bxca0t6o7c00","created":1569738964896,"text":"1. 文件体积大\n2. 速度慢，AOF开启后，Redis支持写的QPS会比RDB支持写的要低","layout":null},"children":[]},{"data":{"id":"c1gbnvv9qqo0","created":1584774467809,"text":"AOF 重写可以产生一个新的 AOF 文件， 这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样， 但体积更小"},"children":[]}]},{"data":{"id":"bydsqm4tvcw0","created":1573549485390,"text":"AOF更适合做热备","layout":null},"children":[]},{"data":{"id":"c1jr0vhmwjs0","created":1585122482238,"text":"AOF文件有自己的存储协议格式","background":"#ffff00"},"children":[]}]},{"data":{"id":"bydsqu35swo0","created":1573549502704,"text":"两种机制全部开启的时候，Redis在重启的时候会默认使用AOF去重新构建数据，因为AOF的数据是比RDB更完整的","color":"#000000","layout":null},"children":[]},{"data":{"id":"c1jr25p2qlk0","created":1585122582819,"text":"混合型持久化"},"children":[{"data":{"id":"c1jr2enpw0g0","created":1585122602328,"text":"一个同时包含 RDB 数据和 AOF 数据的 AOF 文件， 其中 RDB 数据位于 AOF 文件的开头"},"children":[]}]}]},{"data":{"id":"bxc9vs2iuko0","created":1569738570647,"text":"缓存过期策略","layout":null},"children":[{"data":{"id":"bydsfo2cvs00","created":1573548627588,"text":"定时删除","layout":null},"children":[{"data":{"id":"bydsgo2cqxc0","created":1573548705952,"text":"在设置键的过期时间的同时，创建定时器，\n让定时器在键过期时间到来时，即刻执行键值对的删除","layout":null},"children":[{"data":{"id":"c1jr7yzhzg00","created":1585123038397,"text":"定时删除对内存使用率有优势，但是对CPU不友好"},"children":[]}]}]},{"data":{"id":"bydsfo2cvs00","created":1573548627588,"text":"定期删除","layout":null},"children":[{"data":{"id":"bydsgo2cqxc0","created":1573548705952,"text":"默认 100ms 就随机抽一些设置了过期时间的key，\n去检查是否过期，过期了就删了","layout":null},"children":[{"data":{"id":"c1jr87pux6o0","created":1585123057405,"text":"定期删除是定时删除和惰性删除的折中"},"children":[]}]}]},{"data":{"id":"bydsfszz9vk0","created":1573548638329,"text":"惰性删除","layout":null},"children":[{"data":{"id":"bydsh6lsdj40","created":1573548746310,"text":"不主动删，等来查询了看看过期没，\n过期就删了并且不返回，没过期该怎么样就怎么样","layout":null},"children":[{"data":{"id":"c1jr83h0xuo0","created":1585123048164,"text":"惰性删除对内存不友好，如果某些键值对一直不被使用，那么会造成一定量的内存浪费"},"children":[]}]}]},{"data":{"id":"c1jr8i9u1i00","created":1585123080381,"text":"Reids采用的是惰性删除和定期删除的结合","background":"#ffff00","color":"#ff0000","font-weight":"bold","font-size":16},"children":[{"data":{"id":"c1jr93wwtlk0","created":1585123127489,"text":"Redis的设计考虑到时间事件的有限种类和数量，使用了无序链表存储时间事件，\n这样如果在此基础上实现定时删除，就意味着O(N)遍历获取最近需要删除的数据"},"children":[]}]},{"data":{"id":"bydsmgo83xc0","created":1573549160046,"text":"LRU","background":"#92d050","font-weight":"bold","font-size":18,"layout":null},"children":[{"data":{"id":"bydsmik31vk0","created":1573549164149,"text":"Least recently used，最近最少使用","background":"#ffff00","font-weight":"bold","layout":null},"children":[]},{"data":{"id":"bydso4nzplc0","created":1573549290638,"text":"redis 采用近似 LRU 算法","font-weight":"bold","layout":null},"children":[{"data":{"id":"c179vkuktv40","created":1583855388907,"text":"最初，Redis只是随机的选3个key，然后从中淘汰，后来算法改进到N个key的策略，默认是5个"},"children":[]},{"data":{"id":"c179wav90k00","created":1583855445543,"text":"Redis 3.0之后又改善了算法的性能，会提供一个待淘汰候选key的pool，里面默认有16个key，按照空闲时间排好序"},"children":[]}]},{"data":{"id":"bydsoldqhk80","created":1573549327024,"text":"真实的LRU实现是需要太多的内存","layout":null},"children":[]}]}]},{"data":{"id":"bydshtd9bug0","created":1573548795860,"text":"内存淘汰机制","layout":null},"children":[{"data":{"id":"bydtmew2eyw0","created":1573551977276,"text":"缓存过期策略没有生效，大量 key 堆积，走内存淘汰机制","background":"#c0504d","font-weight":"bold","font-size":16,"layout":null},"children":[]},{"data":{"id":"bydsi5uu5uw0","created":1573548823044,"text":"noeviction","layout":null,"font-size":16,"background":"#92d050"},"children":[{"data":{"id":"bydsj5pe1zc0","created":1573548901079,"text":"当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用","layout":null},"children":[]}]},{"data":{"id":"bydsi752w2g0","created":1573548825840,"text":"allkeys-lru","layout":null,"font-size":16,"background":"#92d050"},"children":[{"data":{"id":"bydsjayxepc0","created":1573548912540,"text":"当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）","layout":null,"font-weight":"bold","background":"#ffff00"},"children":[]}]},{"data":{"id":"bydsi8enob40","created":1573548828596,"text":"allkeys-random","layout":null,"font-size":16,"background":"#92d050"},"children":[{"data":{"id":"bydsjnm38x40","created":1573548940062,"text":"当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，一般没人用。\n为啥要随机，肯定是把最近最少使用的 key 给干掉啊","layout":null},"children":[]}]},{"data":{"id":"bydsi7rt2iw0","created":1573548827215,"text":"volatile-lru","layout":null,"font-size":16,"background":"#92d050"},"children":[{"data":{"id":"bydsjivdx340","created":1573548929740,"text":"当内存不足以容纳新写入数据时，\n在设置了过期时间的键空间中，移除最近最少使用的 key\n（这个一般不太合适）","layout":null},"children":[]}]},{"data":{"id":"bydsi92kwz40","created":1573548830043,"text":"volatile-random","layout":null,"font-size":16,"background":"#92d050"},"children":[{"data":{"id":"bydsjrwewfc0","created":1573548949393,"text":"当内存不足以容纳新写入数据时，\n在设置了过期时间的键空间中，随机移除某个 key","layout":null},"children":[]}]},{"data":{"id":"bydsioyjsg80","created":1573548864627,"text":"volatile-ttl","layout":null,"font-size":16,"background":"#92d050"},"children":[{"data":{"id":"bydsjy9z7bk0","created":1573548963274,"text":"当内存不足以容纳新写入数据时，\n在设置了过期时间的键空间中，有更早过期时间的 key 优先移除","layout":null},"children":[]}]},{"data":{"id":"c1jr4scv1ls0","created":1585122788875,"text":"键值对可以分为几种","background":"#92d050","font-weight":"bold","font-size":16},"children":[{"data":{"id":"c1jr54df8ls0","created":1585122815031,"text":"带过期的"},"children":[]},{"data":{"id":"c1jr54dfktc0","created":1585122815031,"text":"不带过期的"},"children":[]},{"data":{"id":"c1jr54dg9zs0","created":1585122815032,"text":"热点数据"},"children":[]},{"data":{"id":"c1jr54dghc80","created":1585122815033,"text":"冷数据"},"children":[]}]},{"data":{"id":"c1jrbo6sl9c0","created":1585123328350,"text":"过期键删除和内存淘汰的关系","font-size":18},"children":[{"data":{"id":"c1jrbv3cye80","created":1585123343380,"text":"过期健删除策略强调的是对过期健的操作，如果有健过期而内存足够，\nRedis不会使用内存淘汰机制来腾退空间，这时会优先使用过期健删除策略删除过期健","font-size":16},"children":[]},{"data":{"id":"c1jrc6hikrs0","created":1585123368181,"text":"内存淘汰机制强调的是对内存数据的淘汰操作，当内存不足时，\n即使有的健没有到达过期时间或者根本没有设置过期也要根据一定的策略来删除一部分，腾退空间保证新数据的写入","font-size":16},"children":[]}]}]},{"data":{"id":"bxc9aeyhqhs0","created":1569736896458,"text":"应用","layout":null},"children":[{"data":{"id":"bxc9b1kmtm00","created":1569736945686,"text":"缓存","layout":null},"children":[]}]},{"data":{"id":"bxca7qq0nzc0","created":1569739508084,"text":"安装","layout":null},"children":[{"data":{"id":"bxca7uuks880","created":1569739517067,"text":"Linux","note":"安装配置","layout":null},"children":[]},{"data":{"id":"bxca7wywbq80","created":1569739521682,"text":"windows","layout":null},"children":[]}]}]},"template":"right","theme":"fish","version":"1.4.43"}